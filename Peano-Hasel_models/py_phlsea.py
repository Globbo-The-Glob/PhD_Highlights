import numpy as np
from sympy import *
import matplotlib.pyplot as plt
from py_functions import getalpha0


print('hello')
'''
TO DO:
[] Write to csv
[] Full loop
[] Test

'''

# Preallocation for loop
Le = np.zeros(10000)
Lp = np.zeros(10000)
alpha0 = np.zeros(10000)
alpha = np.zeros(10000)
A = np.zeros(10000)
h = np.zeros(10000)
le = np.zeros(10000)
lp = np.zeros(10000)
Eper = np.ones(10000)
F = np.zeros(100000)
P = np.zeros(100000)
X = np.zeros(100000)



## Model Constants
Lp[0] = 0.02 # [m] Initial Pouch Length - From original kellaris paper (2018)
perm0 = 8.85418782e-12#[m-3kg-1s4A2]
permr = 2.2 # for BOPP
Eb = 700e6 #[V/m] the breakdown strength of BOPP
w = 0.01 #[m] from original kellaris paper
t = 18e-6 #[m] Bopp thickness used in initial designs
# k = 137e6 #[Nm-1] Achilles tendon average sourced from Litchwark 2005
rho_f = 903 #[kgm-3] Bopp Density TEKRA (2020)
rho_o = 920 #[kgm-3] FR3 Dielectric oil Density Cargill (2018)
alphaf = np.pi/2 #[rad] Assume circular cross section on stroke completion
## Swept constants
Eper[0] = 0.5 # Percentage of electrode coverage
# E = linspace(0,Eb,10); %1x10 Varying field strength [V/m]
E = 700e6

# Combine for force equation 
lamb = E**2*perm0*permr*w*t

# Electrode length initial [m] 1x10
Le[0] = Lp[0]*Eper[0]

## Solves fat optimal fill eqn for alpha0
alpeqn = ((1-Eper)**2)*(2/np.pi)
alpha0[0] = getalpha0(alpeqn)


# gggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggg
# sa0 = sin(alpha0[0])
# sa0a0 = sa0/alpha[0]
# h[0] = Lp[0]*sa0a0
# gggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggg


#Height
h[0] = Lp[0]*(sin(alpha0[0])/alpha0[0]) # Height [m]
#Area w/ restraints 
A[0] = (Lp[0] - Le[0])**2 /np.pi # Area [m2]

# Deformation setup
lp[0] = Lp[0] # no deformation in first stage
le[0] = 0 # no intial zipping
alpha[0] = alpha0[0];
# Voltage
V = 2*t*E 

## Max Force of actuator
Fb = (lamb)*(cos(alpha0[0])/(1-cos(alpha0[0]))) ## Gives max actuator output in [N]
    
k = 0.001    
for n in range(1,10001):   # If the actuator and spring are in eq, no displacement || there is nothing left to zip -> loop ends 
    # Define sub-act geo
    Le[n] = Le[n-1] - le[n-1]                                                     # New electrode coverage is intial minus previous zip
    if Le[n] <= 0:
        break
    else:
        Lp[n] = lp[n-1]                                                               # New pouch length is previous final pouch length
        Eper[n] = Le[n]/Lp[n]                                                         # Calculates electrode coverage percentage
        alpha0[n] = alpha[n-1]                                                         # Sets intial angle as previous final
        A[n] = 0.5*Lp[n]**2*((alpha0[n] - sin(alpha0[n])*cos(alpha0[n]))/alpha0[n]**2)   # New cross section area of sub act from non-optimum fill equation
        h[n] = Lp[n]*(sin(alpha0[n])/alpha0[n])                                        # sub-act height
        ## Sub-act Forces
        sf[n] = lamb*(cos(alpha0[n])/(1-cos(alpha0[n])))
        f[n] = i*sf[n]                                                                 # Calculates force generated by sub-actuator. Factor of j is for array scaling
        # x(1) = 0;                                                                      # test correction term
        p[n] = x[n-1]*k                                                               # Calculates current value of spring tension 
        comp = [f[n],p[n]]
        np.concatenate((Comp,comp), axis=0) 
        if f[n] <= p[n]:
            break
        else:
            ## If can, deform sub-act
            # If actuator is still out forcing spring, there is displacement
            le[n] = le[n-1] + 0.00001*(Le[1])                                               # Incriments zip length by adding a little bit of the original electrode length
            lp[n] = Lp[n] - le[n]                                                          # New pouch length after zip iteration

            if lp[n] <= Le[1]:
                break
            else:
                alpha[n] = getalpha(A, lp[n], n, alpha0[n])         #solves equation for alpha                         
                                                                                            # makes ans final angle of sub-act
                subx[n] = h[n]-(lp[n]*(sin(alpha[n])/alpha[n]) + le[n])                    #Displacement of sub-actuator 
                x[n] = x[n-1]+subx[n]                                                      #Total displacement of full-actuator.
            